<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>False Color Webcam - Dark Mode</title>
    <style>
        :root {
            --primary-color: #007bff;
            --primary-hover-color: #0056b3;
            --body-bg: #1e1e1e;
            --card-bg: #2c2c2c;
            --border-color: #444;
            --text-color: #e0e0e0;
            --text-muted-color: #aaa;
            --input-bg: #383838;
            --button-bg: #3a3a3a;
            --button-hover-bg: #4a4a4a;
            --shadow-color: rgba(0,0,0,0.3);
            --error-bg: #5c2323;
            --error-border: #7a3030;
            --error-text: #f8d7da;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            background-color: var(--body-bg);
            color: var(--text-color);
            line-height: 1.6;
            min-height: 100vh;
            box-sizing: border-box;
        }
        h1 {
            color: #f5f5f5;
            font-weight: 300;
            margin-bottom: 25px;
        }
        .control-panel {
            margin-bottom: 20px;
            padding: 20px;
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 12px var(--shadow-color);
            width: 90%;
            max-width: 800px;
            box-sizing: border-box;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center; 
            justify-content: center; 
        }
        .control-group {
            display: flex;
            flex-direction: column; 
            gap: 5px;
        }
        .control-group > label:not(#falseColorModeLabelContainer), 
        .control-panel > label { 
            font-weight: 500;
            color: var(--text-muted-color);
            font-size: 0.9em;
            margin-bottom: 3px;
            text-align: left; 
        }

        select, button {
            padding: 10px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 1em;
            min-height: 40px; 
            box-sizing: border-box;
        }
        select:focus, button:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }

        #falseColorModeLabelContainer {
            display: flex; 
            align-items: center; 
            color: var(--text-muted-color);
            font-weight: 500;
            font-size: 0.9em;
            cursor: pointer;
            padding: 10px 0; 
            min-height: 40px; 
            box-sizing: border-box;
        }
        #enableFalseColor { 
            margin-right: 8px; 
            transform: scale(1.3);
            accent-color: var(--primary-color);
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            vertical-align: middle; 
        }
       
        #heatmapStyleControlsContainer, #stilgarScopeControlsContainer {
            text-align: center;
        }
        #heatmapStyleButtons, #stilgarScopeCheckboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }
        #heatmapStyleButtons button {
            background-color: var(--button-bg);
            color: var(--text-color);
            cursor: pointer;
            min-width: 90px;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }
        #heatmapStyleButtons button:hover {
            background-color: var(--button-hover-bg);
            border-color: #555;
        }
        #heatmapStyleButtons button.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        #heatmapStyleButtons button.active:hover {
            background-color: var(--primary-hover-color);
        }
        #stilgarScopeCheckboxes > div {
            display: flex;
            align-items: center;
            padding: 6px 10px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
        }
        #stilgarScopeCheckboxes label { 
            font-size: 0.9em;
            color: var(--text-muted-color);
        }
        #webcam { display: none; }
        #canvasOutput {
            border: 2px solid var(--border-color);
            background-color: #000;
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin-bottom: 20px;
            display: block;
            /* image-rendering: pixelated; /* Optional: for crisp pixels when upscaling low-res */
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
        #legendContainer {
            padding: 15px;
            display: flex; 
            flex-direction: column; 
            align-items: center; 
        }
        #legendCanvas {
            border: 1px solid var(--border-color);
            max-width: 100%; 
        }
        .error-message {
            color: var(--error-text);
            font-weight: 500;
            margin-top: 15px;
            background-color: var(--error-bg);
            border: 1px solid var(--error-border);
            padding: 10px 15px;
            border-radius: 6px;
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <h1>False Color Webcam</h1>

    <div id="controls" class="control-panel">
        <div class="control-group">
            <label for="cameraSelect">Camera:</label>
            <select id="cameraSelect">
                <option value="">Default Camera</option>
            </select>
        </div>
        <div class="control-group">
            <label for="resolutionSelect">Stream Resolution:</label>
            <select id="resolutionSelect">
                <option value="default">Default</option>
                <option value="320x240">320x240 (QVGA)</option>
                <option value="640x480" selected>640x480 (VGA)</option>
                <option value="1280x720">1280x720 (HD)</option>
            </select>
        </div>
        <div class="control-group">
            <label for="processingQualitySelect">Processing Quality:</label>
            <select id="processingQualitySelect">
                <option value="high">High (Full Res)</option>
                <option value="medium" selected>Medium (320px wide)</option>
                <option value="low">Low (240px wide)</option>
            </select>
        </div>
        <div class="control-group">
            <label for="falseColorMode">Processing Mode:</label>
            <select id="falseColorMode">
                <option value="heatmap">Heatmap</option>
                <option value="stilgarScope">Stilgar Scope</option>
                <option value="invertedGrayscale">Inverted Grayscale</option>
                <option value="redChannel">Red Channel Dominant</option>
                <option value="greenChannel">Green Channel Dominant</option>
                <option value="blueChannel">Blue Channel Dominant</option>
                <option value="sepia">Sepia</option>
            </select>
        </div>
        <div class="control-group"> 
             <label for="enableFalseColor" id="falseColorModeLabelContainer">
                <input type="checkbox" id="enableFalseColor">
                Enable False Color
            </label>
        </div>
    </div>

    <div id="heatmapStyleControlsContainer" class="control-panel hidden">
        <label>Heatmap Style:</label>
        <div id="heatmapStyleButtons"></div>
    </div>

    <div id="stilgarScopeControlsContainer" class="control-panel hidden">
        <label>Stilgar Scope (Active Stops):</label>
        <div id="stilgarScopeCheckboxes"></div>
    </div>

    <video id="webcam" autoplay playsinline></video>
    <canvas id="canvasOutput"></canvas> {/* This is the visible canvas */}

    <div id="legendContainer" class="control-panel">
        <canvas id="legendCanvas" width="300" height="70"></canvas>
    </div>

    <p id="errorMessage" class="error-message hidden"></p>

    <script>
        const video = document.getElementById('webcam');
        const mainCanvas = document.getElementById('canvasOutput'); // Renamed for clarity
        const mainCtx = mainCanvas.getContext('2d');
        
        // Offscreen canvas for processing
        const processingCanvas = document.createElement('canvas');
        const processingCtx = processingCanvas.getContext('2d');

        const enableFalseColorCheckbox = document.getElementById('enableFalseColor');
        const falseColorModeSelect = document.getElementById('falseColorMode');
        const resolutionSelect = document.getElementById('resolutionSelect');
        const cameraSelect = document.getElementById('cameraSelect'); 
        const processingQualitySelect = document.getElementById('processingQualitySelect'); // New
        const errorMessageElement = document.getElementById('errorMessage');

        const legendCanvas = document.getElementById('legendCanvas');
        const legendCtx = legendCanvas.getContext('2d');

        const heatmapStyleControlsContainer = document.getElementById('heatmapStyleControlsContainer');
        const heatmapStyleButtonsContainer = document.getElementById('heatmapStyleButtons');
        
        const stilgarScopeControlsContainer = document.getElementById('stilgarScopeControlsContainer');
        const stilgarScopeCheckboxesContainer = document.getElementById('stilgarScopeCheckboxes');

        let currentStream = null;
        let streamActive = false;
        let currentHeatmapStyle = 'viridis';
        let videoDevices = []; 

        // --- Stilgar Scope Definitions ---
        const NUM_STILGAR_STOPS = 11;
        const stilgarScopeColors = [
            { r: 138, g: 43,  b: 226 }, { r: 75,  g: 0,   b: 130 }, { r: 0,   g: 0,   b: 255 },
            { r: 0,   g: 191, b: 255 }, { r: 0,   g: 255, b: 0   }, { r: 173, g: 255, b: 47  },
            { r: 255, g: 255, b: 0   }, { r: 255, g: 165, b: 0   }, { r: 255, g: 69,  b: 0   },
            { r: 255, g: 0,   b: 0   }, { r: 139, g: 0,   b: 0   }
        ];
        let activeStilgarStops = new Array(NUM_STILGAR_STOPS).fill(true);

        function createStilgarScopeCheckboxes() {
            stilgarScopeCheckboxesContainer.innerHTML = '';
            for (let i = 0; i < NUM_STILGAR_STOPS; i++) {
                const stopDiv = document.createElement('div');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox'; checkbox.id = `stilgarStop${i}`;
                checkbox.checked = activeStilgarStops[i]; checkbox.dataset.stopIndex = i;
                const label = document.createElement('label');
                label.htmlFor = `stilgarStop${i}`; label.textContent = `Stop ${i + 1}`;
                const swatch = document.createElement('span');
                swatch.style.cssText = `display:inline-block; width:12px; height:12px; background-color:rgb(${stilgarScopeColors[i].r},${stilgarScopeColors[i].g},${stilgarScopeColors[i].b}); margin-left:5px; border:1px solid #555; border-radius:3px;`;
                checkbox.addEventListener('change', (event) => {
                    activeStilgarStops[parseInt(event.target.dataset.stopIndex)] = event.target.checked;
                });
                stopDiv.append(checkbox, label, swatch);
                stilgarScopeCheckboxesContainer.appendChild(stopDiv);
            }
        }

        // --- Heatmap Style Definitions ---
        function interpolateColor(c1, c2, f) { return { r:Math.round(c1.r+f*(c2.r-c1.r)), g:Math.round(c1.g+f*(c2.g-c1.g)), b:Math.round(c1.b+f*(c2.b-c1.b))}; }
        function applyColorScale(intensity, scale) {
            const t = intensity / 255;
            if (!scale || scale.length === 0) return { r: intensity, g: intensity, b: intensity };
            if (scale.length === 1 || t <= scale[0].pos) return scale[0].color;
            if (t >= scale[scale.length - 1].pos) return scale[scale.length - 1].color;
            for (let i = 0; i < scale.length - 1; i++) {
                const s1 = scale[i], s2 = scale[i+1];
                if (s1.pos < s2.pos && t >= s1.pos && t <= s2.pos) return interpolateColor(s1.color, s2.color, (t - s1.pos) / (s2.pos - s1.pos));
                if (s1.pos === s2.pos && t === s1.pos) return s1.color;
            }
            return scale[scale.length-1].color;
        }
        
        const heatmapStyles = { 
            'viridis': { name: 'Viridis', scale: [ { pos: 0.0,  color: { r: 68,  g: 1,   b: 84  } }, { pos: 0.25, color: { r: 59,  g: 82,  b: 139 } }, { pos: 0.5,  color: { r: 33,  g: 145, b: 140 } }, { pos: 0.75, color: { r: 93,  g: 201, b: 99  } }, { pos: 1.0,  color: { r: 253, g: 231, b: 37  } } ], apply: function(i) { return applyColorScale(i, this.scale); } },
            'magma': { name: 'Magma', scale: [ { pos: 0.0,  color: { r: 0,   g: 0,   b: 4   } }, { pos: 0.25, color: { r: 80,  g: 18,  b: 123 } }, { pos: 0.5,  color: { r: 180, g: 58,  b: 114 } }, { pos: 0.75, color: { r: 253, g: 137, b: 33  } }, { pos: 1.0,  color: { r: 251, g: 252, b: 191 } } ], apply: function(i) { return applyColorScale(i, this.scale); } },
            'cividis': { name: 'Cividis', scale: [ { pos: 0.0,  color: { r: 0,   g: 34,  b: 78  } }, { pos: 0.25, color: { r: 44,  g: 79,  b: 117 } }, { pos: 0.5,  color: { r: 96,  g: 126, b: 136 } }, { pos: 0.75, color: { r: 161, g: 173, b: 138 } }, { pos: 1.0,  color: { r: 255, g: 234, b: 70  } } ], apply: function(i) { return applyColorScale(i, this.scale); } },
            'jet': { name: 'Jet', scale: [ { pos: 0.0,   color: { r: 0,   g: 0,   b: 127 } }, { pos: 0.125, color: { r: 0,   g: 0,   b: 255 } }, { pos: 0.375, color: { r: 0,   g: 255, b: 255 } }, { pos: 0.625, color: { r: 255, g: 255, b: 0   } }, { pos: 0.875, color: { r: 255, g: 0,   b: 0   } }, { pos: 1.0,   color: { r: 127, g: 0,   b: 0   } } ], apply: function(i) { return applyColorScale(i, this.scale); } },
            'hot': { name: 'Hot', scale: [ { pos: 0.0,   color: { r: 0,   g: 0,   b: 0   } }, { pos: 0.375, color: { r: 255, g: 0,   b: 0   } }, { pos: 0.75,  color: { r: 255, g: 255, b: 0   } }, { pos: 1.0,   color: { r: 255, g: 255, b: 255 } } ], apply: function(i) { return applyColorScale(i, this.scale); } },
            'coolwarm': { name: 'Coolwarm', scale: [ { pos: 0.0,  color: { r: 59,  g: 76,  b: 192 } }, { pos: 0.25, color: { r: 105, g: 136, b: 221 } }, { pos: 0.5,  color: { r: 224, g: 224, b: 224 } }, { pos: 0.75, color: { r: 220, g: 124, b: 120 } }, { pos: 1.0,  color: { r: 180, g: 4,   b: 38  } } ], apply: function(i) { return applyColorScale(i, this.scale); } },
            'RdBu': { name: 'RdBu', scale: [ { pos: 0.0,  color: { r: 103, g: 0,   b: 31  } }, { pos: 0.25, color: { r: 202, g: 112, b: 87  } }, { pos: 0.5,  color: { r: 247, g: 247, b: 247 } }, { pos: 0.75, color: { r: 122, g: 163, b: 205 } }, { pos: 1.0,  color: { r: 5,   g: 48,  b: 97  } } ], apply: function(i) { return applyColorScale(i, this.scale); } },
            'greys': { name: 'Greys', scale: [ { pos: 0.0, color: { r: 255, g: 255, b: 255 } }, { pos: 0.5, color: { r: 128, g: 128, b: 128 } }, { pos: 1.0, color: { r: 0,   g: 0,   b: 0   } } ], apply: function(i) { return applyColorScale(i, this.scale); } },
            'rainbow': { name: 'Rainbow', scale: [ { pos: 0.0,   color: { r: 255, g: 0,   b: 0   } }, { pos: 0.2,   color: { r: 255, g: 127, b: 0   } }, { pos: 0.4,   color: { r: 255, g: 255, b: 0   } }, { pos: 0.6,   color: { r: 0,   g: 255, b: 0   } }, { pos: 0.8,   color: { r: 0,   g: 0,   b: 255 } }, { pos: 1.0,   color: { r: 139, g: 0,   b: 255 } } ], apply: function(i) { return applyColorScale(i, this.scale); } },
            'turbo': { name: 'Turbo', scale: [ { pos: 0.0,   color: { r: 48,  g: 18,  b: 59  } },  { pos: 0.13,  color: { r: 63,  g: 68,  b: 159 } }, { pos: 0.25,  color: { r: 45,  g: 121, b: 180 } }, { pos: 0.38,  color: { r: 45,  g: 179, b: 114 } }, { pos: 0.5,   color: { r: 121, g: 209, b: 61  } }, { pos: 0.63,  color: { r: 173, g: 220, b: 48  } }, { pos: 0.75,  color: { r: 254, g: 200, b: 41  } }, { pos: 0.88,  color: { r: 250, g: 130, b: 39  } }, { pos: 1.0,   color: { r: 200, g: 50,  b: 33  } } ], apply: function(i) { return applyColorScale(i, this.scale); } }
        };

        function createHeatmapStyleButtons() {
            heatmapStyleButtonsContainer.innerHTML = '';
            Object.keys(heatmapStyles).forEach(key => {
                const btn = document.createElement('button');
                btn.textContent = heatmapStyles[key].name; btn.dataset.style = key;
                if (key === currentHeatmapStyle) btn.classList.add('active');
                btn.addEventListener('click', () => {
                    currentHeatmapStyle = key;
                    heatmapStyleButtonsContainer.querySelectorAll('button').forEach(b => b.classList.toggle('active', b.dataset.style === key));
                    drawLegend();
                });
                heatmapStyleButtonsContainer.appendChild(btn);
            });
        }
        
        async function populateCameraList() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                console.log("enumerateDevices() not supported.");
                cameraSelect.disabled = true; return;
            }
            try {
                // Important: Need to get permission first for full labels
                // A temporary stream request might be needed if no stream is active yet
                if (!currentStream) {
                    const tempStream = await navigator.mediaDevices.getUserMedia({video:true, audio:false});
                    tempStream.getTracks().forEach(track => track.stop()); // Stop temp stream immediately
                }

                const devices = await navigator.mediaDevices.enumerateDevices();
                videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                const currentSelectedId = cameraSelect.value; // Preserve selection if possible
                cameraSelect.innerHTML = '<option value="">Default Camera</option>'; 
                videoDevices.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    let label = device.label || `Camera ${index + 1}`;
                    if (device.label.toLowerCase().includes('front')) label = `Front Camera ${device.label.replace(/front|camera|\(|\)|[0-9]/gi, '').trim() || (index+1)}`;
                    else if (device.label.toLowerCase().includes('back') || device.label.toLowerCase().includes('rear')) label = `Rear Camera ${device.label.replace(/back|rear|camera|\(|\)|[0-9]/gi, '').trim() || (index+1)}`;
                    option.text = label;
                    if(device.deviceId === currentSelectedId) option.selected = true;
                    cameraSelect.appendChild(option);
                });
                cameraSelect.disabled = videoDevices.length <= 1 && !cameraSelect.value; 
            } catch (err) {
                console.error("Error enumerating devices:", err);
            }
        }


        async function setupWebcam() {
            if (currentStream) { currentStream.getTracks().forEach(t => t.stop()); currentStream = null; streamActive = false; }
            
            const selectedDeviceId = cameraSelect.value;
            const selectedResolution = resolutionSelect.value;
            
            let videoConstraints = {};
            if (selectedDeviceId) {
                videoConstraints.deviceId = { exact: selectedDeviceId };
            }

            if (selectedResolution !== 'default') {
                const [width, height] = selectedResolution.split('x').map(Number);
                videoConstraints.width = { ideal: width }; 
                videoConstraints.height = { ideal: height };
            }

            const constraints = { 
                video: Object.keys(videoConstraints).length > 0 ? videoConstraints : true, 
                audio: false 
            };
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = stream; video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    if (video.videoWidth > 0 && video.videoHeight > 0) {
                        // Set main canvas dimensions to match video stream for display
                        mainCanvas.width = video.videoWidth; 
                        mainCanvas.height = video.videoHeight;
                        
                        streamActive = true; errorMessageElement.classList.add('hidden');
                        updateModeControlsVisibility(); drawLegend(); 
                        if(animationFrameId) cancelAnimationFrame(animationFrameId); // Clear previous animation loop
                        drawFrame(); // Start new animation loop
                        
                        // Repopulate camera list here if labels were generic before
                        if (videoDevices.length === 0 || videoDevices.some(d => !d.label || d.label.startsWith("camera"))) {
                           populateCameraList();
                        }
                    } else { setTimeout(() => { if (video.videoWidth > 0) video.onloadedmetadata(); }, 200); }
                };
                video.onplay = () => { // Fallback
                     if (!streamActive && video.videoWidth > 0 && video.videoHeight > 0) {
                         mainCanvas.width = video.videoWidth; mainCanvas.height = video.videoHeight;
                         streamActive = true; errorMessageElement.classList.add('hidden');
                         updateModeControlsVisibility(); drawLegend(); 
                         if(animationFrameId) cancelAnimationFrame(animationFrameId);
                         drawFrame();
                     }
                };
            } catch (err) { /* ... existing error handling ... */ 
                console.error("Webcam Error:", err.name, err.message);
                let friendlyMessage = `Error: ${err.name}. ${err.message}. Ensure camera is connected and permissions are granted.`;
                if (err.name === "OverconstrainedError" || err.name === "ConstraintNotSatisfiedError") {
                    friendlyMessage = `The selected camera/resolution is not supported. Try different settings. Error: ${err.message}`;
                } else if (err.name === "NotAllowedError") {
                    friendlyMessage = `Camera access denied. Please grant permission. Error: ${err.message}`;
                } else if (err.name === "NotFoundError" || err.name === "DevicesNotFoundError") {
                     friendlyMessage = `No camera found. Error: ${err.message}`;
                }
                errorMessageElement.textContent = friendlyMessage;
                errorMessageElement.classList.remove('hidden');
                streamActive = false; updateModeControlsVisibility(); drawLegend();
            }
        }

        function getProcessedPixelColor(r_orig, g_orig, b_orig, mode) {
            const intensity = Math.round((r_orig + g_orig + b_orig) / 3);
            let r = intensity, g = intensity, b = intensity;

            if (mode === 'heatmap') {
                if (heatmapStyles[currentHeatmapStyle] && typeof heatmapStyles[currentHeatmapStyle].apply === 'function') {
                    const color = heatmapStyles[currentHeatmapStyle].apply(intensity);
                    if (color && typeof color.r === 'number') { r = color.r; g = color.g; b = color.b; }
                }
            } else if (mode === 'stilgarScope') {
                const stopW = 255.0 / NUM_STILGAR_STOPS;
                const idx = Math.min(NUM_STILGAR_STOPS - 1, Math.floor(Math.max(0,Math.min(255,intensity)) / stopW));
                if (activeStilgarStops[idx]) { const c = stilgarScopeColors[idx]; r = c.r; g = c.g; b = c.b; }
            } else if (mode === 'invertedGrayscale') { const inv = 255 - intensity; r = inv; g = inv; b = inv;
            } else if (mode === 'redChannel')    { r = intensity; g = Math.round(g_orig * 0.2); b = Math.round(b_orig * 0.2);
            } else if (mode === 'greenChannel')  { r = Math.round(r_orig * 0.2); g = intensity; b = Math.round(b_orig * 0.2);
            } else if (mode === 'blueChannel')   { r = Math.round(r_orig * 0.2); g = Math.round(g_orig * 0.2); b = intensity;
            } else if (mode === 'sepia') {
                r = (r_orig*0.393)+(g_orig*0.769)+(b_orig*0.189); g = (r_orig*0.349)+(g_orig*0.686)+(b_orig*0.168); b = (r_orig*0.272)+(g_orig*0.534)+(b_orig*0.131);
            }
            return { r:Math.max(0,Math.min(255,Math.round(r))), g:Math.max(0,Math.min(255,Math.round(g))), b:Math.max(0,Math.min(255,Math.round(b))) };
        }

        function applyFalseColor(imageData) {
            const data = imageData.data, mode = falseColorModeSelect.value;
            const len = data.length; // Cache length
            for (let i = 0; i < len; i += 4) {
                const p = getProcessedPixelColor(data[i], data[i+1], data[i+2], mode);
                data[i] = p.r; data[i+1] = p.g; data[i+2] = p.b;
            }
        }

        function drawLegend() { /* ... (no changes to legend drawing logic itself) ... */ 
            const mode = falseColorModeSelect.value, w = legendCanvas.width, h = legendCanvas.height;
            const legendTextColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim() || '#e0e0e0'; 

            legendCtx.clearRect(0, 0, w, h);
            legendCtx.font = "bold 0.85em Arial"; 
            legendCtx.fillStyle = legendTextColor; 
            legendCtx.textAlign = "center"; 
            
            let modeName = falseColorModeSelect.options[falseColorModeSelect.selectedIndex].text;
            if (mode === 'heatmap' && heatmapStyles[currentHeatmapStyle]) modeName += ` (${heatmapStyles[currentHeatmapStyle].name})`;
            else if (mode === 'stilgarScope') modeName = "Stilgar Scope";
            legendCtx.fillText(modeName, w / 2, 15);

            const barH = 20, barY = 25, barW = w - 40, barX = 20;
            if (enableFalseColorCheckbox.checked && streamActive) {
                if (mode === 'stilgarScope') {
                    const segW = barW / NUM_STILGAR_STOPS;
                    for (let i = 0; i < NUM_STILGAR_STOPS; i++) {
                        const c = stilgarScopeColors[i]; legendCtx.fillStyle = `rgb(${c.r},${c.g},${c.b})`;
                        legendCtx.fillRect(barX + i * segW, barY, segW, barH);
                    }
                } else {
                    for (let i = 0; i < barW; i++) {
                        const intensity = Math.floor((i / (barW - 1)) * 255);
                        const c = getProcessedPixelColor(intensity, intensity, intensity, mode);
                        legendCtx.fillStyle = `rgb(${c.r},${c.g},${c.b})`;
                        legendCtx.fillRect(barX + i, barY, 1, barH);
                    }
                }
                legendCtx.font = "0.75em Arial"; 
                legendCtx.fillStyle = legendTextColor; 
                legendCtx.textAlign = "left"; legendCtx.fillText("Low", barX, barY + barH + 15);
                legendCtx.textAlign = "right"; legendCtx.fillText("High", barX + barW, barY + barH + 15);
            } else if (!streamActive) { 
                legendCtx.textAlign = "center"; 
                legendCtx.fillText("Legend needs active camera.", w/2, h/2);
            } else { 
                legendCtx.textAlign = "center"; 
                legendCtx.fillText("Enable 'False Color' for legend.", w/2, h/2); 
            }
        }

        let animationFrameId = null;
        function drawFrame() {
            animationFrameId = requestAnimationFrame(drawFrame); // Request next frame immediately

            if (!streamActive || !currentStream || video.paused || video.ended || video.videoWidth === 0 || video.videoHeight === 0 || video.readyState < video.HAVE_CURRENT_DATA) {
                return;
            }
            
            // Ensure main display canvas matches video aspect ratio
            if (mainCanvas.width !== video.videoWidth || mainCanvas.height !== video.videoHeight) {
                mainCanvas.width = video.videoWidth; 
                mainCanvas.height = video.videoHeight;
            }

            let sourceForProcessing = video; // By default, process from the full video stream

            if (enableFalseColorCheckbox.checked) {
                const quality = processingQualitySelect.value;
                let procWidth = video.videoWidth;
                let procHeight = video.videoHeight;

                if (quality === 'medium') {
                    procWidth = 320;
                    procHeight = (video.videoHeight / video.videoWidth) * procWidth;
                } else if (quality === 'low') {
                    procWidth = 240;
                    procHeight = (video.videoHeight / video.videoWidth) * procWidth;
                }
                // Ensure integer dimensions for canvas
                procWidth = Math.round(procWidth);
                procHeight = Math.round(procHeight);

                if (processingCanvas.width !== procWidth || processingCanvas.height !== procHeight) {
                    processingCanvas.width = procWidth;
                    processingCanvas.height = procHeight;
                }

                // Draw video to offscreen processing canvas (scaled down if necessary)
                processingCtx.drawImage(video, 0, 0, processingCanvas.width, processingCanvas.height);
                
                try {
                    const imageData = processingCtx.getImageData(0, 0, processingCanvas.width, processingCanvas.height);
                    applyFalseColor(imageData);
                    processingCtx.putImageData(imageData, 0, 0);
                    sourceForProcessing = processingCanvas; // Now use the processed canvas as the source
                } catch (e) {
                    console.error("Error in false color processing:", e);
                    streamActive = false; 
                    errorMessageElement.textContent = "An error occurred during image processing. Please refresh.";
                    errorMessageElement.classList.remove('hidden');
                    if(animationFrameId) cancelAnimationFrame(animationFrameId);
                    return; 
                }
            }
            
            // Draw to the main visible canvas (either raw video or processed (and potentially upscaled) video)
            mainCtx.drawImage(sourceForProcessing, 0, 0, mainCanvas.width, mainCanvas.height);

        }

        function updateModeControlsVisibility() {
            const currentMode = falseColorModeSelect.value, enabled = enableFalseColorCheckbox.checked;
            heatmapStyleControlsContainer.classList.toggle('hidden', !(currentMode === 'heatmap' && enabled));
            stilgarScopeControlsContainer.classList.toggle('hidden', !(currentMode === 'stilgarScope' && enabled));
            processingQualitySelect.disabled = !enabled; // Disable quality select if false color is off
        }

        // Event Listeners
        cameraSelect.addEventListener('change', setupWebcam); 
        resolutionSelect.addEventListener('change', setupWebcam);
        processingQualitySelect.addEventListener('change', () => {
            // No need to call setupWebcam, just the next drawFrame will use the new quality
            if (streamActive && animationFrameId == null) { // If processing was stopped due to error, restart it
                drawFrame();
            }
        });
        falseColorModeSelect.addEventListener('change', () => { updateModeControlsVisibility(); drawLegend(); });
        enableFalseColorCheckbox.addEventListener('change', () => { updateModeControlsVisibility(); drawLegend(); });

        // Initial Setup
        async function initializeApp() {
            createHeatmapStyleButtons(); 
            createStilgarScopeCheckboxes();
            await populateCameraList(); 
            await setupWebcam();        
            updateModeControlsVisibility(); 
            drawLegend();
        }

        initializeApp();

    </script>
</body>
</html>