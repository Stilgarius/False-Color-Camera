<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>False Color Webcam & Waveform - Dark Mode</title>
    <style>
        :root {
            --primary-color: #007bff;
            --primary-hover-color: #0056b3;
            --body-bg: #1e1e1e;
            --card-bg: #2c2c2c;
            --border-color: #444;
            --text-color: #e0e0e0;
            --text-muted-color: #aaa;
            --input-bg: #383838;
            --button-bg: #3a3a3a;
            --button-hover-bg: #4a4a4a;
            --shadow-color: rgba(0,0,0,0.3);
            --error-bg: #5c2323;
            --error-border: #7a3030;
            --error-text: #f8d7da;
            --waveform-graticule-color: #666;
            --waveform-bg: #101010;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            background-color: var(--body-bg);
            color: var(--text-color);
            line-height: 1.6;
            min-height: 100vh;
            box-sizing: border-box;
        }
        h1 {
            color: #f5f5f5;
            font-weight: 300;
            margin-bottom: 25px;
        }
        .control-panel {
            margin-bottom: 20px;
            padding: 20px;
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 12px var(--shadow-color);
            width: 90%;
            max-width: 800px;
            box-sizing: border-box;
        }
        #topControls, #cameraSpecificControls, #waveformControlsContainer > div {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: flex-start;
            justify-content: center;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 150px; 
        }
        .control-group > label:not(#falseColorModeLabelContainer),
        .control-panel > label {
            font-weight: 500;
            color: var(--text-muted-color);
            font-size: 0.9em;
            margin-bottom: 3px;
            text-align: left;
        }

        select, button, input[type="range"] {
            padding: 10px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 1em;
            min-height: 40px;
            box-sizing: border-box;
        }
        input[type="range"] {
            padding: 0; 
            accent-color: var(--primary-color);
        }
        select:focus, button:focus, input[type="range"]:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }

        #falseColorModeLabelContainer {
            display: flex;
            align-items: center;
            color: var(--text-muted-color);
            font-weight: 500;
            font-size: 0.9em;
            cursor: pointer;
            padding: 10px 0;
            min-height: 40px;
            box-sizing: border-box;
        }
        #enableFalseColor {
            margin-right: 8px;
            transform: scale(1.3);
            accent-color: var(--primary-color);
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            vertical-align: middle;
        }

        #heatmapStyleControlsContainer, #stilgarScopeControlsContainer, #waveformControlsContainer {
            text-align: center; 
        }
        #heatmapStyleButtons, #stilgarScopeCheckboxes { 
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }
        #heatmapStyleButtons button {
            background-color: var(--button-bg);
            color: var(--text-color);
            cursor: pointer;
            min-width: 90px;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }
        #heatmapStyleButtons button:hover {
            background-color: var(--button-hover-bg);
            border-color: #555;
        }
        #heatmapStyleButtons button.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        #heatmapStyleButtons button.active:hover {
            background-color: var(--primary-hover-color);
        }
        #stilgarScopeCheckboxes > div {
            display: flex;
            align-items: center;
            padding: 6px 10px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
        }
        #stilgarScopeCheckboxes label {
            font-size: 0.9em;
            color: var(--text-muted-color);
        }
        #webcam { display: none; }
        #canvasOutput, #waveformCanvas {
            border: 2px solid var(--border-color);
            background-color: #000;
            max-width: 100%;
            height: auto; 
            border-radius: 8px;
            margin-bottom: 20px;
            display: block;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
        #waveformCanvas {
            background-color: var(--waveform-bg);
        }

        #legendContainer {
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #legendCanvas {
            border: 1px solid var(--border-color);
            max-width: 100%;
        }
        #waveformAlphaValueDisplay {
            font-size: 0.8em;
            color: var(--text-muted-color);
            margin-top: 2px;
            display: block;
            text-align: right;
        }
        .error-message {
            color: var(--error-text);
            font-weight: 500;
            margin-top: 15px;
            background-color: var(--error-bg);
            border: 1px solid var(--error-border);
            padding: 10px 15px;
            border-radius: 6px;
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <h1>False Color Webcam & Waveform</h1>

    <div id="topControls" class="control-panel">
        <div class="control-group">
            <label for="cameraSelect">Camera:</label>
            <select id="cameraSelect">
                <option value="">Default Camera</option>
            </select>
        </div>
        <div class="control-group">
            <label for="resolutionSelect">Stream Resolution:</label>
            <select id="resolutionSelect">
                <option value="default">Default</option>
                <option value="320x240">320x240 (QVGA)</option>
                <option value="640x480" selected>640x480 (VGA)</option>
                <option value="1280x720">1280x720 (HD)</option>
            </select>
        </div>
        <div class="control-group">
            <label for="processingQualitySelect">Processing Quality:</label>
            <select id="processingQualitySelect">
                <option value="high">High (Full Res)</option>
                <option value="medium" selected>Medium (320px wide)</option>
                <option value="low">Low (240px wide)</option>
            </select>
        </div>
        <div class="control-group">
            <label for="displayModeSelect">Display Mode:</label>
            <select id="displayModeSelect">
                <option value="camera" selected>Camera View</option>
                <option value="waveform">Waveform</option>
            </select>
        </div>
    </div>
    
    <div id="cameraSpecificControlsContainer">
        <div id="cameraModeControls" class="control-panel">
             <div id="cameraSpecificControls">
                <div class="control-group">
                    <label for="falseColorMode">Processing Mode:</label>
                    <select id="falseColorMode">
                        <option value="heatmap">Heatmap</option>
                        <option value="stilgarScope">Stilgar Scope</option>
                        <option value="invertedGrayscale">Inverted Grayscale</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="enableFalseColor" id="falseColorModeLabelContainer">
                        <input type="checkbox" id="enableFalseColor">
                        Enable False Color
                    </label>
                </div>
            </div>
        </div>

        <div id="heatmapStyleControlsContainer" class="control-panel hidden">
            <label>Heatmap Style:</label>
            <div id="heatmapStyleButtons"></div>
        </div>

        <div id="stilgarScopeControlsContainer" class="control-panel hidden">
            <label>Stilgar Scope (Active Stops):</label>
            <div id="stilgarScopeCheckboxes"></div>
        </div>
    </div>

    <div id="waveformControlsContainer" class="control-panel hidden">
        <div> 
            <div class="control-group">
                <label for="waveformTypeSelect">Waveform Type:</label>
                <select id="waveformTypeSelect">
                    <option value="luma">Luma Waveform</option>
                    <option value="rgb">RGB Waveform</option>
                </select>
            </div>
            <div class="control-group">
                <label for="waveformResolutionSelect">Waveform Display Width:</label>
                <select id="waveformResolutionSelect">
                    <option value="source">Source Processing Width</option>
                    <option value="256">256px Wide</option>
                    <option value="512" selected>512px Wide</option>
                </select>
            </div>
            <div class="control-group">
                <label for="waveformAlphaRange">Brightness (Opacity):</label>
                <input type="range" id="waveformAlphaRange" min="1" max="20" value="10" style="width:100%;">
                <span id="waveformAlphaValueDisplay">0.10</span>
            </div>
            <div class="control-group">
                <label for="waveformPointSizeSelect">Point Size (Thickness):</label>
                <select id="waveformPointSizeSelect">
                    <option value="1" selected>1x1</option>
                    <option value="2">2x2</option>
                    <option value="3">3x3</option>
                </select>
            </div>
        </div>
    </div>

    <video id="webcam" autoplay playsinline></video>
    <canvas id="canvasOutput"></canvas>
    <canvas id="waveformCanvas" class="hidden"></canvas>

    <div id="legendContainer" class="control-panel">
        <canvas id="legendCanvas" width="300" height="70"></canvas>
    </div>

    <p id="errorMessage" class="error-message hidden"></p>

    <script>
        // Cached DOM Elements
        const video = document.getElementById('webcam');
        const mainCanvas = document.getElementById('canvasOutput');
        const mainCtx = mainCanvas.getContext('2d');
        
        const processingCanvas = document.createElement('canvas'); 
        const processingCtx = processingCanvas.getContext('2d');

        const enableFalseColorCheckbox = document.getElementById('enableFalseColor');
        const falseColorModeSelect = document.getElementById('falseColorMode');
        const resolutionSelect = document.getElementById('resolutionSelect');
        const cameraSelect = document.getElementById('cameraSelect'); 
        const processingQualitySelect = document.getElementById('processingQualitySelect');
        const errorMessageElement = document.getElementById('errorMessage');

        const legendCanvas = document.getElementById('legendCanvas');
        const legendCtx = legendCanvas.getContext('2d');
        const legendContainer = document.getElementById('legendContainer');

        const heatmapStyleControlsContainer = document.getElementById('heatmapStyleControlsContainer');
        const heatmapStyleButtonsContainer = document.getElementById('heatmapStyleButtons');
        
        const stilgarScopeControlsContainer = document.getElementById('stilgarScopeControlsContainer');
        const stilgarScopeCheckboxesContainer = document.getElementById('stilgarScopeCheckboxes');

        const displayModeSelect = document.getElementById('displayModeSelect');
        const waveformCanvas = document.getElementById('waveformCanvas');
        const waveformCtx = waveformCanvas.getContext('2d');
        const waveformControlsContainer = document.getElementById('waveformControlsContainer');
        const waveformTypeSelect = document.getElementById('waveformTypeSelect');
        const waveformResolutionSelect = document.getElementById('waveformResolutionSelect');
        const cameraSpecificControlsContainer = document.getElementById('cameraSpecificControlsContainer');
        
        const waveformAlphaRange = document.getElementById('waveformAlphaRange');
        const waveformAlphaValueDisplay = document.getElementById('waveformAlphaValueDisplay');
        const waveformPointSizeSelect = document.getElementById('waveformPointSizeSelect');

        // Global State
        let currentStream = null;
        let streamActive = false;
        let currentHeatmapStyle = 'viridis';
        let videoDevices = []; 
        let animationFrameId = null;

        let currentDisplayMode = 'camera';
        let currentWaveformType = 'luma';
        let currentWaveformResolution = '512'; 
        let currentWaveformAlpha = 0.1; 
        let currentWaveformPointSize = 1; 

        // Constants
        const WAVEFORM_DATA_HEIGHT = 256; 
        const WAVEFORM_GRATICULE_MARGIN_Y = 12; 
        const WAVEFORM_CANVAS_TOTAL_HEIGHT = WAVEFORM_DATA_HEIGHT + 2 * WAVEFORM_GRATICULE_MARGIN_Y;
        const LUMA_COEFFICIENTS = { r: 0.299, g: 0.587, b: 0.114 };

        const NUM_STILGAR_STOPS = 16; 
        const stilgarScopeColors = [ 
            // Stops 1-9: Standard progression
            { r: 138, g: 43,  b: 226 }, // Stop 1 (Violet)
            { r: 75,  g: 0,   b: 130 }, // Stop 2 (Indigo)
            { r: 0,   g: 0,   b: 255 }, // Stop 3 (Blue)
            { r: 0,   g: 191, b: 255 }, // Stop 4 (DeepSkyBlue)
            { r: 0,   g: 255, b: 0   }, // Stop 5 (Green)
            { r: 173, g: 255, b: 47  }, // Stop 6 (GreenYellow)
            { r: 255, g: 255, b: 0   }, // Stop 7 (Yellow)
            { r: 255, g: 165, b: 0   }, // Stop 8 (Orange)
            { r: 255, g: 69,  b: 0   }, // Stop 9 (OrangeRed)
            // Stop 10: Pure Red
            { r: 255, g: 0,   b: 0   }, // Stop 10 (Red)
            // Stops 11-15: Dimming Reds
            { r: 235, g: 0,   b: 0   }, // Stop 11
            { r: 215, g: 0,   b: 0   }, // Stop 12
            { r: 195, g: 0,   b: 0   }, // Stop 13
            { r: 175, g: 0,   b: 0   }, // Stop 14
            { r: 155, g: 0,   b: 0   }, // Stop 15
            // Stop 16: Dark Red (as requested)
            { r: 139, g: 0,   b: 0   }  // Stop 16 (DarkRed)
        ];
        let activeStilgarStops = new Array(NUM_STILGAR_STOPS).fill(true);

        function createStilgarScopeCheckboxes() {
            stilgarScopeCheckboxesContainer.innerHTML = ''; 
            for (let i = 0; i < NUM_STILGAR_STOPS; i++) {
                const stopDiv = document.createElement('div');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox'; checkbox.id = `stilgarStop${i}`;
                checkbox.checked = activeStilgarStops[i]; checkbox.dataset.stopIndex = i;
                
                const label = document.createElement('label');
                label.htmlFor = `stilgarStop${i}`; label.textContent = `Stop ${i + 1}`;
                
                const swatch = document.createElement('span');
                const color = stilgarScopeColors[i];
                swatch.style.cssText = `display:inline-block; width:12px; height:12px; background-color:rgb(${color.r},${color.g},${color.b}); margin-left:5px; border:1px solid #555; border-radius:3px;`;
                
                checkbox.addEventListener('change', (event) => {
                    activeStilgarStops[parseInt(event.target.dataset.stopIndex)] = event.target.checked;
                    if (currentDisplayMode === 'camera') drawLegend();
                });
                stopDiv.append(checkbox, label, swatch);
                stilgarScopeCheckboxesContainer.appendChild(stopDiv);
            }
        }

        function interpolateColor(c1, c2, factor) { 
            return { 
                r: Math.round(c1.r + factor * (c2.r - c1.r)), 
                g: Math.round(c1.g + factor * (c2.g - c1.g)), 
                b: Math.round(c1.b + factor * (c2.b - c1.b))
            }; 
        }
        function applyColorScale(intensity, scale) {
            const t = intensity / 255;
            if (!scale || scale.length === 0) return { r: intensity, g: intensity, b: intensity };
            if (scale.length === 1 || t <= scale[0].pos) return scale[0].color;
            if (t >= scale[scale.length - 1].pos) return scale[scale.length - 1].color;

            for (let i = 0; i < scale.length - 1; i++) {
                const s1 = scale[i], s2 = scale[i+1];
                if (s1.pos < s2.pos && t >= s1.pos && t <= s2.pos) {
                    return interpolateColor(s1.color, s2.color, (t - s1.pos) / (s2.pos - s1.pos));
                }
                if (s1.pos === s2.pos && t === s1.pos) return s1.color; 
            }
            return scale[scale.length-1].color;
        }
        
        const heatmapStyles = { 
            'viridis': { name: 'Viridis', scale: [ { pos: 0.0,  color: { r: 68,  g: 1,   b: 84  } }, { pos: 0.25, color: { r: 59,  g: 82,  b: 139 } }, { pos: 0.5,  color: { r: 33,  g: 145, b: 140 } }, { pos: 0.75, color: { r: 93,  g: 201, b: 99  } }, { pos: 1.0,  color: { r: 253, g: 231, b: 37  } } ], apply: function(i) { return applyColorScale(i, this.scale); } },
            'magma': { name: 'Magma', scale: [ { pos: 0.0,  color: { r: 0,   g: 0,   b: 4   } }, { pos: 0.25, color: { r: 80,  g: 18,  b: 123 } }, { pos: 0.5,  color: { r: 180, g: 58,  b: 114 } }, { pos: 0.75, color: { r: 253, g: 137, b: 33  } }, { pos: 1.0,  color: { r: 251, g: 252, b: 191 } } ], apply: function(i) { return applyColorScale(i, this.scale); } },
            'jet': { name: 'Jet', scale: [ { pos: 0.0,   color: { r: 0,   g: 0,   b: 127 } }, { pos: 0.125, color: { r: 0,   g: 0,   b: 255 } }, { pos: 0.375, color: { r: 0,   g: 255, b: 255 } }, { pos: 0.625, color: { r: 255, g: 255, b: 0   } }, { pos: 0.875, color: { r: 255, g: 0,   b: 0   } }, { pos: 1.0,   color: { r: 127, g: 0,   b: 0   } } ], apply: function(i) { return applyColorScale(i, this.scale); } },
            'hot': { name: 'Hot', scale: [ { pos: 0.0,   color: { r: 0,   g: 0,   b: 0   } }, { pos: 0.375, color: { r: 255, g: 0,   b: 0   } }, { pos: 0.75,  color: { r: 255, g: 255, b: 0   } }, { pos: 1.0,   color: { r: 255, g: 255, b: 255 } } ], apply: function(i) { return applyColorScale(i, this.scale); } },
            'rainbow': { name: 'Rainbow', scale: [ { pos: 0.0,   color: { r: 255, g: 0,   b: 0   } }, { pos: 0.2,   color: { r: 255, g: 127, b: 0   } }, { pos: 0.4,   color: { r: 255, g: 255, b: 0   } }, { pos: 0.6,   color: { r: 0,   g: 255, b: 0   } }, { pos: 0.8,   color: { r: 0,   g: 0,   b: 255 } }, { pos: 1.0,   color: { r: 139, g: 0,   b: 255 } } ], apply: function(i) { return applyColorScale(i, this.scale); } }
        };

        function createHeatmapStyleButtons() {
            heatmapStyleButtonsContainer.innerHTML = ''; 
            Object.keys(heatmapStyles).forEach(key => {
                const btn = document.createElement('button');
                btn.textContent = heatmapStyles[key].name; 
                btn.dataset.style = key;
                if (key === currentHeatmapStyle) btn.classList.add('active');
                
                btn.addEventListener('click', () => {
                    currentHeatmapStyle = key;
                    heatmapStyleButtonsContainer.querySelectorAll('button').forEach(b => {
                        b.classList.toggle('active', b.dataset.style === key);
                    });
                    if (currentDisplayMode === 'camera') drawLegend();
                });
                heatmapStyleButtonsContainer.appendChild(btn);
            });
        }
        
        async function populateCameraList() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                console.warn("enumerateDevices() not supported.");
                cameraSelect.disabled = true; 
                return;
            }
            try {
                if (!currentStream && videoDevices.length === 0) { 
                    const tempStream = await navigator.mediaDevices.getUserMedia({video:true, audio:false});
                    tempStream.getTracks().forEach(track => track.stop());
                }

                const devices = await navigator.mediaDevices.enumerateDevices();
                videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                const currentSelectedId = cameraSelect.value;
                cameraSelect.innerHTML = '<option value="">Default Camera</option>'; 

                videoDevices.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    let label = device.label || `Camera ${index + 1}`;
                    if (device.label.toLowerCase().includes('front')) {
                        label = `Front ${device.label.replace(/front|camera|\(|\)|[0-9]/gi, '').trim() || (index + 1)}`;
                    } else if (device.label.toLowerCase().includes('back') || device.label.toLowerCase().includes('rear')) {
                        label = `Rear ${device.label.replace(/back|rear|camera|\(|\)|[0-9]/gi, '').trim() || (index + 1)}`;
                    }
                    option.text = label;
                    if (device.deviceId === currentSelectedId) option.selected = true;
                    cameraSelect.appendChild(option);
                });
                cameraSelect.disabled = videoDevices.length <= 1 && !cameraSelect.value; 
            } catch (err) {
                console.error("Error enumerating devices:", err);
            }
        }
        
        function handleStreamReady() {
            if (video.videoWidth > 0 && video.videoHeight > 0) {
                if (currentDisplayMode === 'camera') {
                    mainCanvas.width = video.videoWidth;
                    mainCanvas.height = video.videoHeight;
                }
                
                streamActive = true; 
                errorMessageElement.classList.add('hidden');
                updateModeControlsVisibility(); 
                if (currentDisplayMode === 'camera') drawLegend(); 
                
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = null; 
                drawFrame();
                
                if (videoDevices.some(d => !d.label || d.label.startsWith("camera") || d.label.startsWith("Camera"))) {
                   populateCameraList();
                }
            } else { 
                setTimeout(handleStreamReady, 100); 
            }
        }

        async function setupWebcam() {
            if (currentStream) { 
                currentStream.getTracks().forEach(t => t.stop()); 
                currentStream = null; 
                streamActive = false; 
            }
            
            const selectedDeviceId = cameraSelect.value;
            const selectedResolution = resolutionSelect.value;
            
            const videoConstraints = {};
            if (selectedDeviceId) {
                videoConstraints.deviceId = { exact: selectedDeviceId };
            }

            if (selectedResolution !== 'default') {
                const [width, height] = selectedResolution.split('x').map(Number);
                videoConstraints.width = { ideal: width }; 
                videoConstraints.height = { ideal: height };
            }

            const constraints = { 
                video: Object.keys(videoConstraints).length > 0 ? videoConstraints : true, 
                audio: false 
            };
            
            try {
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = currentStream;
                
                video.onloadedmetadata = handleStreamReady;
                video.onplay = () => {
                     if (!streamActive) handleStreamReady();
                };
                if (video.readyState >= video.HAVE_METADATA) {
                    handleStreamReady();
                }

            } catch (err) {  
                console.error("Webcam Error:", err.name, err.message);
                let friendlyMessage = `Error: ${err.name}. ${err.message}. Ensure camera is connected and permissions are granted.`;
                if (err.name === "OverconstrainedError" || err.name === "ConstraintNotSatisfiedError") {
                    friendlyMessage = `The selected camera/resolution is not supported. Try different settings. Error: ${err.message}`;
                } else if (err.name === "NotAllowedError" || err.name === "PermissionDeniedError") {
                    friendlyMessage = `Camera access denied. Please grant permission. Error: ${err.message}`;
                } else if (err.name === "NotFoundError" || err.name === "DevicesNotFoundError") {
                     friendlyMessage = `No camera found. Error: ${err.message}`;
                }
                errorMessageElement.textContent = friendlyMessage;
                errorMessageElement.classList.remove('hidden');
                streamActive = false; 
                updateModeControlsVisibility(); 
                if (currentDisplayMode === 'camera') drawLegend();
            }
        }

        function getProcessedPixelColor(r_orig, g_orig, b_orig, mode) {
            const intensity = Math.round((r_orig + g_orig + b_orig) / 3);
            let r = intensity, g = intensity, b = intensity;

            if (mode === 'heatmap') {
                const style = heatmapStyles[currentHeatmapStyle];
                if (style && typeof style.apply === 'function') {
                    const color = style.apply(intensity);
                    if (color && typeof color.r === 'number') { 
                        r = color.r; g = color.g; b = color.b; 
                    }
                }
            } else if (mode === 'stilgarScope') {
                const stopWidth = 255.0 / NUM_STILGAR_STOPS;
                const stopIndex = Math.min(NUM_STILGAR_STOPS - 1, Math.floor(Math.max(0, Math.min(255, intensity)) / stopWidth));
                if (activeStilgarStops[stopIndex]) { 
                    const color = stilgarScopeColors[stopIndex];
                    r = color.r; g = color.g; b = color.b; 
                }
            } else if (mode === 'invertedGrayscale') { 
                const invertedIntensity = 255 - intensity; 
                r = invertedIntensity; g = invertedIntensity; b = invertedIntensity;
            }

            return { 
                r: Math.max(0, Math.min(255, Math.round(r))), 
                g: Math.max(0, Math.min(255, Math.round(g))), 
                b: Math.max(0, Math.min(255, Math.round(b))) 
            };
        }

        function applyFalseColor(imageData) {
            const data = imageData.data;
            const currentProcessingMode = falseColorModeSelect.value;
            const len = data.length; 
            for (let i = 0; i < len; i += 4) {
                const pColor = getProcessedPixelColor(data[i], data[i+1], data[i+2], currentProcessingMode);
                data[i]   = pColor.r;
                data[i+1] = pColor.g;
                data[i+2] = pColor.b;
            }
        }

        function drawLegend() { 
            const mode = falseColorModeSelect.value;
            const w = legendCanvas.width;
            const h = legendCanvas.height;
            const legendTextColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim() || '#e0e0e0'; 

            legendCtx.clearRect(0, 0, w, h);
            legendCtx.font = "bold 0.85em Arial"; 
            legendCtx.fillStyle = legendTextColor; 
            legendCtx.textAlign = "center"; 
            
            let modeName = falseColorModeSelect.options[falseColorModeSelect.selectedIndex].text;
            if (mode === 'heatmap' && heatmapStyles[currentHeatmapStyle]) {
                modeName += ` (${heatmapStyles[currentHeatmapStyle].name})`;
            } else if (mode === 'stilgarScope') {
                modeName = "Stilgar Scope";
            }
            legendCtx.fillText(modeName, w / 2, 15);

            const barH = 20, barY = 25, barW = w - 40, barX = 20;
            if (enableFalseColorCheckbox.checked && streamActive) {
                if (mode === 'stilgarScope') {
                    const segmentWidth = barW / NUM_STILGAR_STOPS;
                    for (let i = 0; i < NUM_STILGAR_STOPS; i++) {
                        const color = stilgarScopeColors[i]; 
                        legendCtx.fillStyle = `rgb(${color.r},${color.g},${color.b})`;
                        legendCtx.fillRect(barX + i * segmentWidth, barY, segmentWidth, barH);
                    }
                } else {
                    for (let i = 0; i < barW; i++) {
                        const intensity = Math.floor((i / (barW - 1)) * 255);
                        const pColor = getProcessedPixelColor(intensity, intensity, intensity, mode);
                        legendCtx.fillStyle = `rgb(${pColor.r},${pColor.g},${pColor.b})`;
                        legendCtx.fillRect(barX + i, barY, 1, barH);
                    }
                }
                legendCtx.font = "0.75em Arial"; 
                legendCtx.fillStyle = legendTextColor; 
                legendCtx.textAlign = "left"; legendCtx.fillText("Low", barX, barY + barH + 15);
                legendCtx.textAlign = "right"; legendCtx.fillText("High", barX + barW, barY + barH + 15);
            } else if (!streamActive) { 
                legendCtx.textAlign = "center"; 
                legendCtx.fillText("Legend needs active camera.", w/2, h/2);
            } else { 
                legendCtx.textAlign = "center"; 
                legendCtx.fillText("Enable 'False Color' for legend.", w/2, h/2); 
            }
        }
        
        function drawWaveformGraticule() {
            const wfWidth = waveformCanvas.width;
            const dataHeight = WAVEFORM_DATA_HEIGHT; 
            const yOffset = WAVEFORM_GRATICULE_MARGIN_Y; 

            waveformCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--waveform-graticule-color').trim() || '#666';
            waveformCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-muted-color').trim() || '#aaa';
            waveformCtx.font = "10px Arial";
            waveformCtx.textAlign = "left";

            const levels = [
                { val: 0, label: "0%" },    { val: 64, label: "25%" },  
                { val: 128, label: "50%" }, { val: 191, label: "75%" }, 
                { val: 255, label: "100%" } 
            ];

            levels.forEach(level => {
                const yPos = (dataHeight - 1 - level.val) + yOffset;
                waveformCtx.beginPath();
                waveformCtx.moveTo(0, yPos + 0.5); 
                waveformCtx.lineTo(wfWidth, yPos + 0.5);
                waveformCtx.stroke();
                waveformCtx.fillText(level.label, 5, yPos - 2);
            });
        }

        function drawLumaWaveform(imageData, imgWidth, imgHeight) {
            const data = imageData.data;
            const wfDisplayWidth = waveformCanvas.width;
            const dataPlotHeight = WAVEFORM_DATA_HEIGHT;
            const yPlotOffset = WAVEFORM_GRATICULE_MARGIN_Y;
            const pointSize = currentWaveformPointSize;
            const xScaleFactor = wfDisplayWidth / imgWidth;

            waveformCtx.fillStyle = `rgba(180, 255, 180, ${currentWaveformAlpha})`;

            for (let x = 0; x < imgWidth; x++) {
                const wfX = Math.floor(x * xScaleFactor);
                for (let y = 0; y < imgHeight; y++) {
                    const offset = (y * imgWidth + x) * 4;
                    const r = data[offset];
                    const g = data[offset + 1];
                    const b = data[offset + 2];
                    const luma = Math.round(LUMA_COEFFICIENTS.r * r + LUMA_COEFFICIENTS.g * g + LUMA_COEFFICIENTS.b * b);
                    
                    const wfYOnDataArea = dataPlotHeight - 1 - luma;
                    const wfYCanvas = wfYOnDataArea + yPlotOffset;

                    waveformCtx.fillRect(wfX, wfYCanvas, pointSize, pointSize);
                }
            }
        }

        function drawRGBWaveform(imageData, imgWidth, imgHeight) {
            const data = imageData.data;
            const wfDisplayWidth = waveformCanvas.width;
            const dataPlotHeight = WAVEFORM_DATA_HEIGHT;
            const yPlotOffset = WAVEFORM_GRATICULE_MARGIN_Y;
            const pointSize = currentWaveformPointSize;
            const alpha = currentWaveformAlpha;
            const xScaleFactor = wfDisplayWidth / imgWidth;

            waveformCtx.globalCompositeOperation = 'lighter'; 

            for (let x = 0; x < imgWidth; x++) {
                const wfX = Math.floor(x * xScaleFactor);
                for (let y = 0; y < imgHeight; y++) {
                    const offset = (y * imgWidth + x) * 4;
                    const rVal = data[offset];
                    const gVal = data[offset + 1];
                    const bVal = data[offset + 2];

                    const wfYr = (dataPlotHeight - 1 - rVal) + yPlotOffset;
                    const wfYg = (dataPlotHeight - 1 - gVal) + yPlotOffset;
                    const wfYb = (dataPlotHeight - 1 - bVal) + yPlotOffset;

                    waveformCtx.fillStyle = `rgba(255, 60, 60, ${alpha})`; 
                    waveformCtx.fillRect(wfX, wfYr, pointSize, pointSize);
                    
                    waveformCtx.fillStyle = `rgba(60, 255, 60, ${alpha})`; 
                    waveformCtx.fillRect(wfX, wfYg, pointSize, pointSize);
                    
                    waveformCtx.fillStyle = `rgba(60, 60, 255, ${alpha})`; 
                    waveformCtx.fillRect(wfX, wfYb, pointSize, pointSize);
                }
            }
            waveformCtx.globalCompositeOperation = 'source-over'; 
        }

        function drawWaveform(sourceDataCanvas) {
            if (!sourceDataCanvas || sourceDataCanvas.width === 0 || sourceDataCanvas.height === 0) {
                console.warn("Waveform source canvas is invalid.");
                return;
            }

            const imgWidth = sourceDataCanvas.width;
            const imgHeight = sourceDataCanvas.height;

            if (currentWaveformResolution === 'source') {
                waveformCanvas.width = imgWidth > 0 ? imgWidth : 512; 
            } else {
                waveformCanvas.width = parseInt(currentWaveformResolution, 10);
            }
            waveformCanvas.height = WAVEFORM_CANVAS_TOTAL_HEIGHT;

            waveformCtx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
            drawWaveformGraticule();

            try {
                const imageData = sourceDataCanvas.getContext('2d').getImageData(0, 0, imgWidth, imgHeight);
                if (currentWaveformType === 'luma') {
                    drawLumaWaveform(imageData, imgWidth, imgHeight);
                } else if (currentWaveformType === 'rgb') {
                    drawRGBWaveform(imageData, imgWidth, imgHeight);
                }
            } catch (e) {
                console.error("Error getting/processing image data for waveform:", e);
                waveformCtx.fillStyle = 'red';
                waveformCtx.font = '12px Arial';
                waveformCtx.textAlign = 'center';
                waveformCtx.fillText('Error processing waveform data', waveformCanvas.width / 2, waveformCanvas.height / 2);
            }
        }

        function drawFrame() {
            animationFrameId = requestAnimationFrame(drawFrame); 

            if (!streamActive || !currentStream || video.paused || video.ended || 
                video.videoWidth === 0 || video.videoHeight === 0 || 
                video.readyState < video.HAVE_CURRENT_DATA) {
                return; 
            }
            
            if (currentDisplayMode === 'camera' && 
                (mainCanvas.width !== video.videoWidth || mainCanvas.height !== video.videoHeight)) {
                mainCanvas.width = video.videoWidth; 
                mainCanvas.height = video.videoHeight;
            }

            let procWidth = video.videoWidth;
            let procHeight = video.videoHeight;
            const quality = processingQualitySelect.value;

            if (quality === 'medium') {
                procWidth = 320;
                procHeight = (video.videoHeight / video.videoWidth) * procWidth;
            } else if (quality === 'low') {
                procWidth = 240;
                procHeight = (video.videoHeight / video.videoWidth) * procWidth;
            }
            procWidth = Math.max(1, Math.round(procWidth));
            procHeight = Math.max(1, Math.round(procHeight));

            if (processingCanvas.width !== procWidth || processingCanvas.height !== procHeight) {
                processingCanvas.width = procWidth;
                processingCanvas.height = procHeight;
            }
            
            processingCtx.drawImage(video, 0, 0, processingCanvas.width, processingCanvas.height);
            
            const sourceForEffectsOrWaveform = processingCanvas;

            if (currentDisplayMode === 'camera' && enableFalseColorCheckbox.checked) {
                try {
                    const imageData = processingCtx.getImageData(0, 0, processingCanvas.width, processingCanvas.height);
                    applyFalseColor(imageData);
                    processingCtx.putImageData(imageData, 0, 0);
                } catch (e) {
                    console.error("Error in false color processing:", e);
                    streamActive = false; 
                    errorMessageElement.textContent = "An error occurred during image processing. Please refresh.";
                    errorMessageElement.classList.remove('hidden');
                    if(animationFrameId) cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                    return; 
                }
            }
            
            if (currentDisplayMode === 'camera') {
                mainCtx.drawImage(sourceForEffectsOrWaveform, 0, 0, mainCanvas.width, mainCanvas.height);
            } else if (currentDisplayMode === 'waveform') {
                drawWaveform(sourceForEffectsOrWaveform);
            }
        }

        function updateModeControlsVisibility() {
            const isCameraMode = currentDisplayMode === 'camera';
            const falseColorEffectActive = enableFalseColorCheckbox.checked; 

            mainCanvas.classList.toggle('hidden', !isCameraMode);
            waveformCanvas.classList.toggle('hidden', isCameraMode);

            cameraSpecificControlsContainer.classList.toggle('hidden', !isCameraMode);
            waveformControlsContainer.classList.toggle('hidden', isCameraMode);
            legendContainer.classList.toggle('hidden', !isCameraMode);

            if (isCameraMode) {
                const currentFalseColorMode = falseColorModeSelect.value;
                heatmapStyleControlsContainer.classList.toggle('hidden', !(currentFalseColorMode === 'heatmap' && falseColorEffectActive));
                stilgarScopeControlsContainer.classList.toggle('hidden', !(currentFalseColorMode === 'stilgarScope' && falseColorEffectActive));
            } else { 
                heatmapStyleControlsContainer.classList.add('hidden');
                stilgarScopeControlsContainer.classList.add('hidden');
            }
            
            processingQualitySelect.disabled = false;
        }

        // --- Event Listeners ---
        cameraSelect.addEventListener('change', setupWebcam); 
        resolutionSelect.addEventListener('change', setupWebcam);
        
        processingQualitySelect.addEventListener('change', () => {
            if (streamActive && animationFrameId == null) { 
                drawFrame();
            }
        });

        falseColorModeSelect.addEventListener('change', () => { 
            updateModeControlsVisibility(); 
            if (currentDisplayMode === 'camera') drawLegend(); 
        });
        enableFalseColorCheckbox.addEventListener('change', () => { 
            updateModeControlsVisibility(); 
            if (currentDisplayMode === 'camera') drawLegend(); 
        });

        displayModeSelect.addEventListener('change', (e) => {
            currentDisplayMode = e.target.value;
            updateModeControlsVisibility();
            if (currentDisplayMode === 'camera' && streamActive) {
                drawLegend();
                if (video.videoWidth > 0 && video.videoHeight > 0) {
                    mainCanvas.width = video.videoWidth;
                    mainCanvas.height = video.videoHeight;
                }
            }
        });

        waveformTypeSelect.addEventListener('change', (e) => {
            currentWaveformType = e.target.value;
        });
        waveformResolutionSelect.addEventListener('change', (e) => {
            currentWaveformResolution = e.target.value;
        });

        waveformAlphaRange.addEventListener('input', (e) => {
            currentWaveformAlpha = parseFloat(e.target.value) / 100;
            waveformAlphaValueDisplay.textContent = currentWaveformAlpha.toFixed(2);
        });
        waveformPointSizeSelect.addEventListener('change', (e) => {
            currentWaveformPointSize = parseInt(e.target.value, 10);
        });

        // --- Initial Setup ---
        async function initializeApp() {
            waveformAlphaValueDisplay.textContent = currentWaveformAlpha.toFixed(2);
            waveformAlphaRange.value = (currentWaveformAlpha * 100).toString();
            waveformPointSizeSelect.value = currentWaveformPointSize.toString();

            createHeatmapStyleButtons(); 
            createStilgarScopeCheckboxes();

            await populateCameraList(); 
            await setupWebcam();       
        }

        initializeApp().catch(err => {
            console.error("Initialization failed:", err);
            errorMessageElement.textContent = "Application initialization failed. Please refresh.";
            errorMessageElement.classList.remove('hidden');
        });

    </script>
</body>
</html>